// @ts-nocheck
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openProjectWindow(rootPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_project_window", { rootPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createNewWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_new_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async registerWindowProject(rootPath: string | null) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("register_window_project", { rootPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async closeWindow() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("close_window") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async listDirectoryRecursive(path: string, settings: IgnoreSettings) : Promise<Result<FileNode, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("list_directory_recursive", { path, settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRelativePath(fullPath: string, rootPath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_relative_path", { fullPath, rootPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readFileContent(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_file_content", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readFileAsBase64(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_file_as_base64", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isBinaryFile(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_binary_file", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async fileExists(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("file_exists", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeFileContent(path: string, content: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_file_content", { path, content }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteFile(filePath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_file", { filePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async moveFile(from: string, to: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("move_file", { from, to }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backupFiles(rootPath: string, filePaths: string[]) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backup_files", { rootPath, filePaths }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async revertFileFromBackup(rootPath: string, backupId: string, relativePath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("revert_file_from_backup", { rootPath, backupId, relativePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async readFileFromBackup(backupId: string, relativePath: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("read_file_from_backup", { backupId, relativePath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteBackup(backupId: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_backup", { backupId }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async parseChangesFromMarkdown(markdown: string, rootPath: string) : Promise<Result<ChangeOperation[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("parse_changes_from_markdown", { markdown, rootPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async isGitRepository(path: string) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_git_repository", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGitStatus(repoPath: string) : Promise<Result<GitStatus, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_status", { repoPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getRecentCommits(repoPath: string, count: number) : Promise<Result<Commit[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_recent_commits", { repoPath, count }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGitDiff(repoPath: string, option: DiffOption) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_git_diff", { repoPath, option }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resolvePath(path: string, cwd: string | null) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resolve_path", { path, cwd }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startPtySession(rootPath: string, command: string | null, onEvent: TAURI_CHANNEL<CommandStreamEvent>) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_pty_session", { rootPath, command, onEvent }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resizePty(rows: number, cols: number) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resize_pty", { rows, cols }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async writeToPty(text: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("write_to_pty", { text }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async killPty() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("kill_pty") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getCliStatus() : Promise<Result<CliStatusResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_cli_status") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async installCliShim() : Promise<Result<CliInstallResult, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("install_cli_shim") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async startWatching(rootPath: string, settings: IgnoreSettings) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("start_watching", { rootPath, settings }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopWatching(rootPath: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_watching", { rootPath }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async searchFiles(query: string, rootPath: string, settings: IgnoreSettings, limit: number | null) : Promise<Result<SearchResult[], string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("search_files", { query, rootPath, settings, limit }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type ChangeOperation = { type: "patch"; filePath: string; content: string; isNewFile: boolean; totalBlocks: number; appliedBlocks: number } | { type: "overwrite"; filePath: string; content: string; isNewFile: boolean } | { type: "delete"; filePath: string } | { type: "move"; fromPath: string; toPath: string }
export type CliInstallResult = { message: string }
export type CliStatus = "installed" | "not_installed" | "error"
export type CliStatusResult = { status: CliStatus; error: string | null }
export type CommandStreamEvent = { type: "stdout"; data: number[] } | { type: "stderr"; data: number[] } | { type: "error"; data: string } | { type: "finish"; data: string }
export type Commit = { hash: string; message: string; author: string; date: string }
export type DiffOption = { type: "staged" } | { type: "unstaged" } | { type: "commit"; hash: string }
export type FileNode = { path: string; name: string; children?: FileNode[] | null; isDirectory: boolean }
export type GitStatus = { hasStagedChanges: boolean; hasUnstagedChanges: boolean }
export type IgnoreSettings = { respectGitignore: boolean; customIgnorePatterns: string }
export type SearchResult = { path: string; relativePath: string; name: string; parentDir: string; score: number; isDirectory: boolean }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
